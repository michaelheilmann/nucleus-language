#include <stdlib.h>  // For atexit(), EXIT_SUCCESS and EXIT_FAILURE.
#include <stdio.h>   // For FILE, fopen(), fclose(), and fprintf().
#include <stdint.h>  // For uint32_t.
#include <string.h>  // For strdup().
#include <stdbool.h> // For bool.

#include "Nucleus/CommandLine.h"

static char *cs_cat(const char *v, const char *w)
{
    char *u = malloc(strlen(v) + strlen(w) + 1);
    if (!u) return NULL;
    strcpy(u, v);
    strcat(u, w);
    return u;
}

static bool cs_eq(const char *v, const char *w)
{ return (0 == strcmp(v, w)); }

typedef enum PassPolicy
{
    PassPolicy_PassByValue = 1,
    PassPolicy_PassByPointer = 2,
} PassPolicy;

typedef struct Type
{
    const char *typeName;
    const char *variableName;
    PassPolicy passPolicy;
} Type;

/// @brief The list of code points.
static const Type g_types[] =
{
#define TYPE(typeName, variableName, passPolicy) { typeName, variableName, PassPolicy_##passPolicy },

#include "Nucleus/Interpreter/Tools/Generator/Types.i"

#undef TYPE
}; // g_types

/// @brief The number of types in @a g_types.
static const size_t g_numberOfTypes = sizeof(g_types) / sizeof(Type);

static Nucleus_CommandLine_Command *g_cmd = NULL;

static void atExit(void)
{
    if (g_cmd)
    {
        Nucleus_CommandLine_Command_destroy(g_cmd);
        g_cmd = NULL;
    }
}

static Nucleus_NonNull() setterSig
    (
        const Type *type,
        const char *objectTypeName,
        const char *objectVariableName,
        const char *prefix,
        FILE *file
    )
{
    fprintf(file,
            "%sNonNull() void\n"
            "%s%s_set%s\n"
            "    (\n"
            "        %sContext *context,\n"
            "        %s%s *Nucleus_Interpreter_Restrict() %s,\n"
            "        %s%s %s%s\n"
            "    )",
            prefix,
            prefix, objectTypeName,
            type->typeName,
            prefix,
            prefix, objectTypeName, objectVariableName,
            prefix, type->typeName, type->passPolicy == PassPolicy_PassByPointer ? "*" : "", type->variableName);
    return Nucleus_Status_Success;
}

static Nucleus_NonNull() getterSig
    (
        const Type *type,
        const char *objectTypeName,
        const char *objectVariableName,
        const char *prefix,
        FILE *file
    )
{
    fprintf(file,
            "%sNonNull() %s%s %s\n"
            "%s%s_get%s\n"
            "    (\n"
            "        %sContext *context,\n"
            "        %s%s *Nucleus_Interpreter_Restrict() %s\n"
            "    )",
            prefix,
            prefix, type->typeName, type->passPolicy == PassPolicy_PassByPointer ? "*" : "",
            prefix, objectTypeName,
            type->typeName,
            prefix,
            prefix, objectTypeName, objectVariableName);
    return Nucleus_Status_Success;
}

typedef Nucleus_Status GeneratorFunction(Nucleus_CommandLine_Command *command, const char *prefix, FILE *file);

static Nucleus_Status generatorBase(Nucleus_CommandLine_Command *command,
                                    const char *prefix,
                                    const char *pathnamePrefix,
                                    GeneratorFunction *generateHeaderFunction,
                                    GeneratorFunction *generateSourceFunction)
{
    FILE *file;
    char *pathname;
    Nucleus_Status status;

    // Write header.
    pathname = cs_cat(pathnamePrefix, ".h");
    if (!pathname)
    { return Nucleus_Status_AllocationFailed; }
    file = fopen(pathname, "w");
    if (!file)
    { free(pathname); return Nucleus_Status_WriteError; }
    status = generateHeaderFunction(command, prefix, file);
    if (status) { fclose(file); free(pathname); return status; }
    fclose(file);
    free(pathname);

    // Write source.
    pathname = cs_cat(pathnamePrefix, ".c");
    if (!pathname)
    { return Nucleus_Status_AllocationFailed; }
    file = fopen(pathname, "w");
    if (!file)
    { free(pathname); return Nucleus_Status_WriteError; }
    status = generateSourceFunction(command, prefix, file);
    if (status) { fclose(file); free(pathname); return status; }
    fclose(file);
    free(pathname);

    return Nucleus_Status_Success;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static Nucleus_Status generateTagHeaderFile(Nucleus_CommandLine_Command *command, const char *prefix, FILE *file)
{
    fprintf(file, "/* Generated by Nucleus.Interpreter.Tools.Generator */\n");
    fprintf(file, "#pragma once\n\n");
    fprintf(file, "typedef enum %sTag %sTag;\n\n", prefix, prefix);
    fprintf(file, "enum %sTag\n", prefix);
    fprintf(file, "{\n");
    for (size_t i = 0, n = g_numberOfTypes; i < n; ++i)
    {
        const Type *type = &(g_types[i]);
        fprintf(file, "  %sTag_%s,\n",
                prefix,
                type->typeName);
    }
    fprintf(file, "}; // enum %sTag\n", prefix);
    return Nucleus_Status_Success;
}

static Nucleus_Status generateTagSourceFile(Nucleus_CommandLine_Command *command, const char *prefix, FILE *file)
{
    fprintf(file, "/* Generated by Nucleus.Interpreter.Tools.Generator */\n");
    fprintf(file, "#include \"%s/Tag.h\"\n", "Nucleus/Interpreter");
    return Nucleus_Status_Success;
}

static Nucleus_Status generateTag(Nucleus_CommandLine_Command *command, const char *prefix, const char *pathnamePrefix)
{ return generatorBase(command, prefix, pathnamePrefix, &generateTagHeaderFile, &generateTagSourceFile); }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static Nucleus_Status generateValueHeaderFile(Nucleus_CommandLine_Command *command, const char *prefix, FILE *file)
{
    fprintf(file, "/* Generated by Nucleus.Interpreter.Tools.Generator */\n");
    fprintf(file, "#pragma once\n\n");
    fprintf(file, "#include \"%s/Types.h\"\n\n", "Nucleus/Interpreter");
    fprintf(file, "typedef union %sValue %sValue;\n\n", prefix, prefix);
    fprintf(file, "union %sValue\n", prefix);
    fprintf(file, "{\n");
    for (size_t i = 0, n = g_numberOfTypes; i < n; ++i)
    {
        const Type *type = &(g_types[i]);
        fprintf(file, "   %s%s %s%s;\n",
                prefix,
                type->typeName,
                type->passPolicy == PassPolicy_PassByPointer ? "*" : "",
                type->variableName);
    }
    fprintf(file, "}; // union %sValue\n", prefix);
    for (size_t i = 0, n = g_numberOfTypes; i < n; ++i)
    {
        const Type *type = &(g_types[i]);
        fprintf(file, "\n\n");
        getterSig(type, "Value", "value", prefix, file);
        fprintf(file, ";\n");
        fprintf(file, "\n");
        setterSig(type, "Value", "value", prefix, file);
        fprintf(file, ";\n");
    }
    return Nucleus_Status_Success;
}

static Nucleus_Status generateValueSourceFile(Nucleus_CommandLine_Command *command, const char *prefix, FILE *file)
{
    fprintf(file, "/* Generated by Nucleus.Interpreter.Tools.Generator */\n");
    fprintf(file, "#include \"%s/Value.h\"\n", "Nucleus/Interpreter");
    for (size_t i = 0, n = g_numberOfTypes; i < n; ++i)
    {
        const Type *type = &(g_types[i]);
        fprintf(file, "\n\n");
        getterSig(type, "Value", "value", prefix, file);
        fprintf(file, "\n");
        fprintf(file, "{ return value->%s; }\n\n", type->variableName);
        setterSig(type, "Value", "value", prefix, file);
        fprintf(file, "\n\n");
        fprintf(file, "{ value->%s = %s; }\n", type->variableName, type->variableName);
    }
    return Nucleus_Status_Success;
}


static Nucleus_Status generateValue(Nucleus_CommandLine_Command *command, const char *prefix, const char *pathnamePrefix)
{ return generatorBase(command, prefix, pathnamePrefix, &generateValueHeaderFile, &generateValueSourceFile); }

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static Nucleus_Status generateTaggedValueHeaderFile(Nucleus_CommandLine_Command *command, const char *prefix, FILE *file)
{
    fprintf(file, "/* Generated by Nucleus.Interpreter.Tools.Generator */\n");
    fprintf(file, "#pragma once\n\n");
    fprintf(file, "#include \"%s/Tag.h\"\n", "Nucleus/Interpreter");
    fprintf(file, "#include \"%s/Value.h\"\n\n", "Nucleus/Interpreter");
    fprintf(file, "typedef struct %sTaggedValue %sTaggedValue;\n\n", prefix, prefix);
    fprintf(file, "struct %sTaggedValue\n", prefix);
    fprintf(file, "{\n");
    fprintf(file, "    %sTag tag;\n", prefix);
    fprintf(file, "    %sValue value;\n", prefix);
    fprintf(file, "}; // struct %sTaggedValue\n", prefix);
    for (size_t i = 0, n = g_numberOfTypes; i < n; ++i)
    {
        const Type *type = &(g_types[i]);
        fprintf(file, "\n\n");
        fprintf(file,
                "%sNonNull() bool\n"
                "%sTaggdedValue_is%s\n"
                "    (\n"
                "        %sContext *context,\n"
                "        %sTaggedValue const *Nucleus_Interpreter_Restrict() taggedValue\n"
                "    );\n",
                prefix, prefix,
                type->typeName,
                prefix,
                prefix);
        fprintf(file, "\n");
        getterSig(type, "TaggedValue", "taggedValue", prefix, file);
        fprintf(file, ";\n");
        fprintf(file, "\n");
        setterSig(type, "TaggedValue", "taggedValue", prefix, file);
        fprintf(file, ";\n");
    }
    return Nucleus_Status_Success;
}

static Nucleus_Status generateTaggedValueSourceFile(Nucleus_CommandLine_Command *command, const char *prefix, FILE *file)
{
    fprintf(file, "/* Generated by Nucleus.Interpreter.Tools.Generator */\n");
    fprintf(file, "#include \"%s/TaggedValue.h\"\n", "Nucleus/Interpreter");
    for (size_t i = 0, n = g_numberOfTypes; i < n; ++i)
    {
        const Type *type = &(g_types[i]);
        fprintf(file, "\n\n");
        //
        fprintf(file,
                "%sNonNull() bool\n"
                "%sTaggdedValue_is%s\n"
                "    (\n"
                "        %sContext *context,\n"
                "        %sTaggedValue const *Nucleus_Interpreter_Restrict() taggedValue\n"
                "    )",
                prefix, prefix,
                type->typeName,
                prefix,
                prefix);
        fprintf(file, "\n{\n");
        fprintf(file, "    return %sTag_%s == taggedValue->tag;\n",
                      prefix, type->typeName);
        fprintf(file, "}\n");
        fprintf(file, "\n");
        //
        getterSig(type, "TaggedValue", "taggedValue", prefix, file);
        fprintf(file, "\n{\n");
        fprintf(file, "    return %sValue_get%s(context, &(taggedValue->value));\n",
                      prefix, type->typeName);
        fprintf(file, "}\n");
        fprintf(file, "\n");
        //
        setterSig(type, "TaggedValue", "taggedValue", prefix, file);
        fprintf(file, "\n{\n");
        fprintf(file, "    %sValue_set%s(context, &(taggedValue->value), %s);\n",
                      prefix, type->typeName, type->variableName);
        fprintf(file, "}\n");
        fprintf(file, "\n");
    }
    return Nucleus_Status_Success;
}

static Nucleus_Status generateTaggedValue(Nucleus_CommandLine_Command *command, const char *prefix, const char *pathnamePrefix)
{ return generatorBase(command, prefix, pathnamePrefix, &generateTaggedValueHeaderFile, &generateTaggedValueSourceFile); }

int main(int argc, char **argv)
{
    Nucleus_Status status;

    // Register at exit function.
    if (atexit(&atExit))
    { fprintf(stderr, "atexit() failed\n"); exit(EXIT_FAILURE); }

    // Parse command.
    if (Nucleus_CommandLine_parse(&g_cmd, argc, argv))
    { exit(EXIT_FAILURE); }

    // Check number of arguments. Must be two (the input file, the output file).
    size_t n;
    if (Nucleus_CommandLine_Command_getParameterCount(g_cmd, &n))
    { exit(EXIT_FAILURE); }
    if (n < 2)
    {
        fprintf(stderr, "too few arguments\n");
        exit(EXIT_FAILURE);
    }

    // Assert "prefix=<string>" option is present and proper.
    Nucleus_CommandLine_Option *prefixOption;
    status = Nucleus_CommandLine_Command_getOption(g_cmd, "prefix", &prefixOption);
    if (status && status != Nucleus_Status_NotExists)
    {
        fprintf(stderr, "<internal error>\n");
        exit(EXIT_FAILURE);
    }
    if (status == Nucleus_Status_NotExists)
    {
        fprintf(stderr, "missing 'prefix' option\n");
        exit(EXIT_FAILURE);
    }
    if (Nucleus_CommandLine_Option_getParameterCount(prefixOption, &n))
    {
        exit(EXIT_FAILURE);
    }
    if (n != 1)
    {
        fprintf(stderr, "'prefix' option requires one parameter\n");
        exit(EXIT_FAILURE);
    }
    Nucleus_CommandLine_Parameter *prefixParameter;
    if (Nucleus_CommandLine_Option_getParameter(prefixOption, 0, &prefixParameter))
    {
        exit(EXIT_FAILURE);
    }
    const char *prefixParameterValue;
    if (Nucleus_CommandLine_Parameter_getValue(prefixParameter, &prefixParameterValue))
    { exit(EXIT_FAILURE); }
    fprintf(stdout, "prefix=%s\n", prefixParameterValue);

    // Assert "--generator=("Tag"|"Value"|"TaggedValue")" is present and proper.
    Nucleus_CommandLine_Option *generatorOption;
    status = Nucleus_CommandLine_Command_getOption(g_cmd, "generator", &generatorOption);
    if (status && status != Nucleus_Status_NotExists)
    {
        fprintf(stderr, "<internal error>\n");
        exit(EXIT_FAILURE);
    }
    if (status == Nucleus_Status_NotExists)
    {
        fprintf(stderr, "missing 'generator' option\n");
        exit(EXIT_FAILURE);
    }
    if (Nucleus_CommandLine_Option_getParameterCount(generatorOption, &n))
    {
        exit(EXIT_FAILURE);
    }
    if (n != 1)
    {
        fprintf(stderr, "'generator' option requires one parameter\n");
        exit(EXIT_FAILURE);
    }
    Nucleus_CommandLine_Parameter *generatorParameter;
    if (Nucleus_CommandLine_Option_getParameter(generatorOption, 0, &generatorParameter))
    { exit(EXIT_FAILURE); }
    const char *generatorParameterValue;
    if (Nucleus_CommandLine_Parameter_getValue(generatorParameter, &generatorParameterValue))
    { exit(EXIT_FAILURE); }
    fprintf(stdout, "generator=%s\n", generatorParameterValue);
    if (!cs_eq(generatorParameterValue, "Tag") &&
        !cs_eq(generatorParameterValue, "Value") &&
        !cs_eq(generatorParameterValue, "Tagged Value"))
    {
        fprintf(stderr, "'generator' option requires either 'Tag', 'Value', or 'TaggedValue', received '%s'\n", generatorParameterValue);
        exit(EXIT_FAILURE);
    }

    // Generate!
    Nucleus_CommandLine_Parameter *targetPathnameParameter;
    if (Nucleus_CommandLine_Command_getParameter(g_cmd, 1, &targetPathnameParameter))
    {
        exit(EXIT_FAILURE);
    }
    const char *targetPathnameParameterValue;
    if (Nucleus_CommandLine_Parameter_getValue(targetPathnameParameter, &targetPathnameParameterValue))
    { exit(EXIT_FAILURE); }
    fprintf(stdout, "targetPathnamePrefix=%s\n", targetPathnameParameterValue);
    if (cs_eq(generatorParameterValue, "Tag"))
    {
        status = generateTag(g_cmd, prefixParameterValue, targetPathnameParameterValue);
    }
    else if (cs_eq(generatorParameterValue, "Value"))
    {
        status = generateValue(g_cmd, prefixParameterValue, targetPathnameParameterValue);
    }
    else if (cs_eq(generatorParameterValue, "Tagged Value"))
    {
        status = generateTaggedValue(g_cmd, prefixParameterValue, targetPathnameParameterValue);
    }
    return EXIT_SUCCESS;
}
